// ------------------------------------------------------------------
//   sam_xcons.c
//   Copyright (C) 2022-2026 Genozip Limited. Patent pending.
//   Please see terms and conditions in the file LICENSE.txt
//
//   WARNING: Genozip is proprietary, not open source software. Modifying the source code is strictly prohibited,
//   under penalties specified in the license.

// Compresses auxilliary fields generated by BSBolt

#include "sam_private.h"
#include "codec.h"

// calculate the xcons histogram just in case we need it (we don't yet know if this file is really xcons, just that it has XC:i)
void sam_segconf_xcons_one_line (VBlockSAMP vb, ZipDataLineSAMP dl)
{
    // xcons: to find standard length, we build a histogram of all lines with XC:i but without XO:i. we do this anyway, bc we don't yet know if it is indeed xcons.
    if (ctx_encountered_in_line (VB, OPTION_XC_i) && !ctx_encountered_in_line (VB, OPTION_XO_i) && 
        IN_RANGX (dl->QUAL.len, MIN_XCONS_STD_QUAL_LEN, MAX_XCONS_STD_QUAL_LEN))
        segconf.xcons_std_line_histogram[dl->QUAL.len - MIN_XCONS_STD_QUAL_LEN]++;
}

// discover if xcons-style consensus reads
void sam_segconf_finalize_xcons (void)
{
    if (segconf_qf_id(QNAME1) == QF_Sint && segconf_qf_id(QNAME2) == QF_XCON && 
        segconf.has[OPTION_XX_i] && segconf.has[OPTION_YY_i] && segconf.has[OPTION_XC_i] && segconf.has[OPTION_XO_i]) {
        segconf.sam_has_xcons = true;
        segconf.sam_has_BWA_XC_i = false;
    
        uint32_t max_i=0, max_value=0;
        for (int i=0; i < ARRAY_LEN(segconf.xcons_std_line_histogram); i++)
            if (segconf.xcons_std_line_histogram[i] > max_value) {
                max_value = segconf.xcons_std_line_histogram[i];
                max_i = i;
            }

        // note: it is possible that in an xcons file, segconf lines do not contain any of standard length.
        // in this case, xcons_std_seq_len will remain 0 and special DOMQ will not apply 
        if (max_value) 
            segconf.xcons_std_seq_len = max_i + MIN_XCONS_STD_QUAL_LEN; 
    }
}

void sam_xcons_seg_initialize (VBlockSAMP vb)
{
    ctx_set_dyn_int (VB, SAM_CQUAL, OPTION_YY_i, OPTION_XO_i, DID_EOL);
    
    seg_mux_init (vb, OPTION_YY_i, SAM_SPECIAL_DEMUX_BY_XX_0, false, YY);
}

static int64_t XO_prediction (uint32_t seq_len)
{
    return (seq_len <= segconf.xcons_std_seq_len) ? seq_len
                                                  : (2 * segconf.xcons_std_seq_len - seq_len);
}

void sam_seg_xcons_XO (VBlockSAMP vb, ZipDataLineSAMP dl, int64_t xo, unsigned add_bytes)
{
    decl_ctx (OPTION_XO_i);

    dl->XO = MAX_(0, MIN_(xo, MAX_xcons_XO)); 
    int64_t prediction = XO_prediction (dl->SEQ.len);

    if (prediction == xo) {
        seg_special0 (VB, SAM_SPECIAL_xcons_XO, ctx, add_bytes);
        dl->XO_predicted = true;
    }
    else 
        seg_integer (VB, ctx, xo, true, add_bytes);
}

// for backcomp: 15.0.27 to 15.0.75
SPECIAL_RECONSTRUCTOR (sam_piz_special_DEMUX_BY_AS_old)
{
    int64_t as = reconstruct_peek (vb, CTX(OPTION_AS_i), 0, 0).i;
    
    int channel_i = (as == vb->seq_len);

    return reconstruct_demultiplex (vb, ctx, STRa(snip), channel_i, new_value, reconstruct);
}

SPECIAL_RECONSTRUCTOR (sam_piz_special_xcons_XO)
{
    if (!VER2(15,76)) // backcomp: 15.0.27 to 15.0.75
        return sam_piz_special_DEMUX_BY_AS_old (vb, ctx, STRa(snip), new_value, reconstruct);

    new_value->i = XO_prediction (vb->seq_len);

    if (reconstruct) RECONSTRUCT_INT (new_value->i);

    return HAS_NEW_VALUE;
}

// YY is predicted to be non-0 iff XX is 0
void sam_seg_xcons_YY (VBlockSAMP vb, int64_t yy, unsigned add_bytes)
{
    int channel_i = ctx_has_value_in_line_(VB, CTX(OPTION_XX_i)) && !CTX(OPTION_XX_i)->last_value.i;

    ContextP channel_ctx = seg_mux_get_channel_ctx (VB, OPTION_YY_i, (MultiplexerP)&vb->mux_YY, channel_i);

    seg_integer (VB, channel_ctx, yy, false, add_bytes);
    ctx_set_last_value (VB, CTX(OPTION_YY_i), yy);

    seg_by_did (VB, STRa(vb->mux_YY.snip), OPTION_YY_i, 0); // de-multiplexer
}

SPECIAL_RECONSTRUCTOR (sam_piz_special_DEMUX_BY_XX_0)
{
    int channel_i = ctx_has_value_in_line_(VB, CTX(OPTION_XX_i)) && !CTX(OPTION_XX_i)->last_value.i;

    return reconstruct_demultiplex (vb, ctx, STRa(snip), channel_i, new_value, reconstruct);
}

// XC is predicted to be XX + YY + XY
void sam_seg_xcons_XC (VBlockSAMP vb, ZipDataLineSAMP dl, int64_t xc, unsigned add_bytes)
{
    int64_t prediction = 0;
    if (ctx_has_value_in_line_(VB, CTX(OPTION_XX_i))) prediction += CTX(OPTION_XX_i)->last_value.i;
    if (ctx_has_value_in_line_(VB, CTX(OPTION_YY_i))) prediction += CTX(OPTION_YY_i)->last_value.i;
    if (ctx_has_value_in_line_(VB, CTX(OPTION_XY_i))) prediction += CTX(OPTION_XY_i)->last_value.i;
    
    if (xc == prediction)
        seg_by_did (VB, STRa(XC_snip), OPTION_XC_i, add_bytes);

    else
        seg_integer (VB, CTX(OPTION_XC_i), xc, true, add_bytes);
}

// modify segged array
ARRAY_ITEM_CALLBACK (sam_seg_xcons_XD_callback)
{
    if (width != 4) {
        WARN_ONCE ("%s: sam_seg_xcons_XD_callback with width=%u. Please notify %s. Genozip handled this file correctly - no worries.", VB_NAME, width, EMAIL_SUPPORT);
        return; // TO DO: do we need to support other widths?
    }

    uint32_t *values = (uint32_t *)array;
    
    ARRAY_alloc (bool, is_predicted, array_len, true, vb->scratch, vb, "scratch");
    
    // verify array is monolithic-increasing
    for (uint32_t i=1; i < array_len; i++)  
        if (values[i] <= values[i-1]) return; // unexpected format - keep default segging

    // seg snip
    for (uint32_t i=0; i < array_len; i++) {
        is_predicted[i] = values[i] == (i ? (values[i-1] + 1) : 0);

        seg_special1 (VB, SAM_SPECIAL_xcons_XD, '0' + is_predicted[i], ctx, 0);
    }

    // shorten array to just those unpredicted - and set them to the delta
    uint32_t prev_value = 0;
    uint32_t old=0, new=0; for (; old < array_len; old++) {
        uint32_t this_value = values[old]; // save as it can be overwritten

        if (!is_predicted[old])
            values[new++] = this_value - prev_value; 

        prev_value = this_value;
    }
    ctx->local.len -= (old - new) * width; // calculation in bytes

    buf_free (vb->scratch);
}

SPECIAL_RECONSTRUCTOR (sam_piz_special_xcons_XD)
{
    bool is_predicted = (*snip == '1');
    bool first_item   = !ctx_encountered_in_line (vb, ctx->did_i);

    if (first_item) 
        new_value->i = is_predicted ? 0: reconstruct_from_local_int (VB, ctx, 0, RECON_OFF);

    else
        new_value->i = ctx->last_value.i + (is_predicted ? 1 : reconstruct_from_local_int (VB, ctx, 0, RECON_OFF));
                                    
    if (reconstruct) RECONSTRUCT_INT (new_value->i);

    return HAS_NEW_VALUE;
}

#define FIRST_Q 32  // first valid quality (in SAM terms) (' '=32 if QUAL="*")
#define LAST_Q  127 // note: 127 if QUAL="*" (missing qual) in a PySam BAM file

// find a segment of length xo within the qual line, for which qual scores differ the most 
// vs. the left and right flanking segments
static int sam_xcons_split_qual_line_by_xo (VBlockSAMP vb, STR8c(qual), DomqLine *segments, int64_t xo)
{
    // initialize hisograms
    uint32_t xo_histo[128] = {}, flank_histo[128] = {}; // actually only using 32...127    
    for (uint32_t i=0; i < xo; i++)
        xo_histo[qual[i]]++;

    for (uint32_t i=xo; i < qual_len; i++)
        flank_histo[qual[i]]++;

    int uniq_xo=0, uniq_flank=0;

    for (int q=FIRST_Q; q <= LAST_Q; q++) {
        if (xo_histo[q]) uniq_xo++;
        if (flank_histo[q]) uniq_flank++;
    }

    // we optimize for the offset of the xo segment resulting in minimal total uniq xo
    int min_offset = 0;
    int min_uniq = uniq_flank + uniq_xo;

    // now find the best offset (=smallest min_uniq)
    for (int offset=1; offset < qual_len - xo; offset++) {
        int left_q  = qual[offset-1];    // the position the xo left and is now flank
        int right_q = qual[offset+xo-1]; // the position the xo entered and is no longer flank

        // update histogram for left_q moving from xo to flank
        if ((--xo_histo[left_q]) == 0) uniq_xo--; // remove from uniq if histogram reached 0

        if ((flank_histo[left_q]++) == 0) uniq_flank++;

        // update histogram for right_q moving from flank to xo
        if ((--flank_histo[right_q]) == 0) uniq_flank--;

        if ((xo_histo[right_q]++) == 0) uniq_xo++;

        // check if this offset is better
        if (uniq_flank + uniq_xo < min_uniq) {
            min_uniq   = uniq_flank + uniq_xo;
            min_offset = offset;
        }
    }

    // record results in segments
    if (min_offset) 
        segments[0] = (DomqLine){ .qual = qual, .qual_len = min_offset };
                    
    segments[1] = (DomqLine){ .qual = qual + min_offset, .qual_len = xo };
    
    if (min_offset + xo < qual_len)
        segments[2] = (DomqLine){ .qual = qual + min_offset + xo, .qual_len = qual_len - xo - min_offset };

    seg_integer (VB, CTX(SAM_CQUAL), min_offset, false, 0);

    return (segments[0].qual_len > 0) + 1 + (segments[2].qual_len > 0); // number of segments
}

// Used for DOMQ compression of xcons QUAL: split each QUAL line into (up to 3) segments
void sam_xcons_split_qual_line (VBlockP vb_, BufferP ql_buf)
{
    VBlockSAMP vb = (VBlockSAMP)vb_;

    ASSERTNOTINUSE (vb->scratch);
    ARRAY_alloc (DomqLine, segments, ql_buf->len * 3, true, vb->scratch, vb, "scratch");
    int n_segments = 0;

    for_buf2 (DomqLine, ql, line_i, *ql_buf) {
        ZipDataLineSAMP dl = DATA_LINE (line_i);
        DomqLine *s0=&segments[line_i*3], *s1=s0+1, *s2=s1+1;

        if (!ql->qual_len) continue;

        // if XO covers the whole qual (which may or may not be XO_predicted), or if there is no valid XO
        if (dl->XO >= ql->qual_len || dl->XO <= 0) {
            *s1 = *ql;
            n_segments++;
        }
        
        // if predicted - XO is precisely at the center of the QUAL
        else if (dl->XO_predicted) {
            int flank = (ql->qual_len - dl->XO) / 2;
            *s0 = (DomqLine){ .qual = ql->qual,                  .qual_len = flank  };
            *s1 = (DomqLine){ .qual = ql->qual + flank,          .qual_len = dl->XO };
            *s2 = (DomqLine){ .qual = ql->qual + flank + dl->XO, .qual_len = ql->qual_len - dl->XO - flank };
            n_segments += 3;
        }

        // XO is smaller than predicted and smaller than qual_len - search for the location
        else 
            n_segments += sam_xcons_split_qual_line_by_xo (vb, STRa(ql->qual), s0, dl->XO);
    }

    // resize ql_buf and copy updated lines
    buf_alloc_exact (vb, *ql_buf, n_segments, DomqLine, NULL);
    
    DomqLine *ql = B1ST(DomqLine, *ql_buf);
    for (int seg_i=0; seg_i < segments_len; seg_i++)
        if (segments[seg_i].qual_len) 
            *ql++ = segments[seg_i];

    ASSERT (ql == BAFT(DomqLine, *ql_buf), "wrong number of segments: delta=%d", 
            (int)(ql - BAFT(DomqLine, *ql_buf)));

    buf_free (vb->scratch);
}

void sam_xcons_reconstruct_QUAL (VBlockP vb, ContextP ctx, uint32_t qual_len, bool reconstruct)
{
    ASSISLOADED (CTX(OPTION_XO_i));
    ASSISLOADED (CTX(SAM_AUX));
    
    int64_t xo = sam_piz_peek_OPTION (VB_SAM, CTX(OPTION_XO_i), 0, 0, 0).i; // 0 if XO doesn't exist

    int64_t prediction = XO_prediction (qual_len);

    // case: single segment 
    if (xo >= qual_len || xo <= 0) 
        codec_domq_reconstruct (vb, 0, ctx, qual_len, reconstruct);
    
    // case: three segments - XO is precisely at the center of the QUAL
    else if (xo == prediction) {
        int flank = (qual_len - xo) / 2;
        codec_domq_reconstruct (vb, 0, ctx, flank,                 reconstruct);
        codec_domq_reconstruct (vb, 0, ctx, xo,                    reconstruct);
        codec_domq_reconstruct (vb, 0, ctx, qual_len - xo - flank, reconstruct);
    }

    // case: xo offset recorded in CQUAL: (up to) three segments: left-flank, xo, right-flank
    else {
        ASSISLOADED (CTX(SAM_CQUAL));

        int64_t offset = reconstruct_from_local_int (vb, CTX(SAM_CQUAL), 0, RECON_OFF);
        
        if (offset) codec_domq_reconstruct (vb, 0, ctx, offset, reconstruct); 
        codec_domq_reconstruct (vb, 0, ctx, xo, reconstruct);
        if (qual_len > offset + xo) codec_domq_reconstruct (vb, 0, ctx, qual_len - (xo + offset), reconstruct);
    }
}
